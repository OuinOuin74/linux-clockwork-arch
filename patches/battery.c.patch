--- /drivers/power/supply/axp20x_battery.c	Fri Aug  1 08:41:28 2025
+++ /drivers/power/supply/axp20x_battery.c	Fri Aug  1 10:26:29 2025
@@ -81,6 +81,10 @@
 #define AXP20X_V_OFF_MASK		GENMASK(2, 0)
 #define AXP717_V_OFF_MASK		GENMASK(6, 4)
 
+#define AXP228_FULL_CAPACITY_CALIBRATE_EN BIT(5)
+#define AXP228_CAPACITY_CALIBRATE BIT(4)
+#define AXP228_CALIBRATE_MASK (BIT(4) | BIT(5))
+
 #define AXP717_BAT_VMIN_MIN_UV		2600000
 #define AXP717_BAT_VMIN_MAX_UV		3300000
 #define AXP717_BAT_VMIN_STEP		100000
@@ -89,8 +93,6 @@
 #define AXP717_BAT_CC_MIN_UA		0
 #define AXP717_BAT_CC_MAX_UA		3008000
 
-#define AXP717_TS_PIN_DISABLE		BIT(4)
-
 struct axp20x_batt_ps;
 
 struct axp_data {
@@ -118,8 +120,10 @@
 	struct iio_channel *batt_v;
 	/* Maximum constant charge current */
 	unsigned int max_ccc;
+	int energy_full_design;
+	int current_now;
+	int voltage_now;
 	const struct axp_data	*data;
-	bool ts_disable;
 };
 
 static int axp20x_battery_get_max_voltage(struct axp20x_batt_ps *axp20x_batt,
@@ -369,6 +373,8 @@
 		if (ret)
 			return ret;
 
+		axp20x_batt->current_now = val->intval;
+
 		break;
 
 	case POWER_SUPPLY_PROP_CAPACITY:
@@ -416,6 +422,63 @@
 		if (ret)
 			return ret;
 
+		axp20x_batt->current_now = val->intval;
+		
+		break;
+
+	case POWER_SUPPLY_PROP_ENERGY_FULL:
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+		/* When no battery is present, return 0 */
+		ret = regmap_read(axp20x_batt->regmap, AXP20X_PWR_OP_MODE,
+				  &reg);
+		if (ret)
+			return ret;
+
+		if (!(reg & AXP20X_PWR_OP_BATT_PRESENT)) {
+			val->intval = 0;
+			return 0;
+		}
+
+		if (psp == POWER_SUPPLY_PROP_ENERGY_FULL) {
+			// TODO
+			val->intval = axp20x_batt->energy_full_design;
+			return 0;
+		}
+
+		if (psp == POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN) {
+			val->intval = axp20x_batt->energy_full_design;
+			return 0;
+		}
+
+		ret = regmap_read(axp20x_batt->regmap, AXP20X_FG_RES, &reg);
+		if (ret)
+			return ret;
+
+		if (axp20x_batt->data->has_fg_valid && !(reg & AXP22X_FG_VALID))
+			return -EINVAL;
+
+		val1 = reg & AXP209_FG_PERCENT;
+		val1 = max(min(val1, 100), 0);
+		val->intval =
+			(val1 *
+			 ((long long int)axp20x_batt->energy_full_design)) /
+			100;
+		break;
+
+	case POWER_SUPPLY_PROP_CALIBRATE:
+		// report both calibrate enable flag and calibration status
+		ret = regmap_read(axp20x_batt->regmap, AXP20X_CC_CTRL, &reg);
+		if (ret)
+			return ret;
+		val1 = reg & AXP228_CALIBRATE_MASK;
+		val->intval = val1;
+		break;
+
+	case POWER_SUPPLY_PROP_POWER_NOW:
+		val->intval = (axp20x_batt->voltage_now / 10000) *
+			      axp20x_batt->current_now;
+		val->intval = val->intval / 100; // uW
 		break;
 
 	default:
@@ -771,6 +834,7 @@
 				   const union power_supply_propval *val)
 {
 	struct axp20x_batt_ps *axp20x_batt = power_supply_get_drvdata(psy);
+	int val1;
 
 	switch (psp) {
 	case POWER_SUPPLY_PROP_VOLTAGE_MIN:
@@ -778,7 +842,17 @@
 
 	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
 		return axp20x_batt->data->set_max_voltage(axp20x_batt, val->intval);
-
+	case POWER_SUPPLY_PROP_CALIBRATE:
+		if (val->intval) {
+			// enable calibrate
+			val1 = AXP228_FULL_CAPACITY_CALIBRATE_EN |
+			       AXP228_CAPACITY_CALIBRATE;
+		} else {
+			// disable calibrate
+			val1 = 0;
+		}
+		return regmap_update_bits(axp20x_batt->regmap, AXP20X_CC_CTRL,
+					  AXP228_CALIBRATE_MASK, val1);
 	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:
 		return axp20x_set_constant_charge_current(axp20x_batt,
 							  val->intval);
@@ -850,6 +924,11 @@
 	POWER_SUPPLY_PROP_VOLTAGE_MAX,
 	POWER_SUPPLY_PROP_VOLTAGE_MIN,
 	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_ENERGY_FULL,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CALIBRATE,
+	POWER_SUPPLY_PROP_POWER_NOW,
 };
 
 static enum power_supply_property axp717_battery_props[] = {
@@ -873,7 +952,8 @@
 	       psp == POWER_SUPPLY_PROP_VOLTAGE_MIN ||
 	       psp == POWER_SUPPLY_PROP_VOLTAGE_MAX ||
 	       psp == POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT ||
-	       psp == POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX;
+	       psp == POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX ||
+	       psp == POWER_SUPPLY_PROP_CALIBRATE;
 }
 
 static int axp717_battery_prop_writeable(struct power_supply *psy,
@@ -987,24 +1067,6 @@
 	int ccc = info->constant_charge_current_max_ua;
 	int val;
 
-	axp_batt->ts_disable = (device_property_read_bool(axp_batt->dev,
-							  "x-powers,no-thermistor"));
-
-	/*
-	 * Under rare conditions an incorrectly programmed efuse for
-	 * the temp sensor on the PMIC may trigger a fault condition.
-	 * Allow users to hard-code if the ts pin is not used to work
-	 * around this problem. Note that this requires the battery
-	 * be correctly defined in the device tree with a monitored
-	 * battery node.
-	 */
-	if (axp_batt->ts_disable) {
-		regmap_update_bits(axp_batt->regmap,
-				   AXP717_TS_PIN_CFG,
-				   AXP717_TS_PIN_DISABLE,
-				   AXP717_TS_PIN_DISABLE);
-	}
-
 	if (vmin > 0 && axp717_set_voltage_min_design(axp_batt, vmin))
 		dev_err(&pdev->dev,
 			"couldn't set voltage_min_design\n");
@@ -1131,6 +1193,29 @@
 	if (!power_supply_get_battery_info(axp20x_batt->batt, &info)) {
 		axp20x_batt->data->set_bat_info(pdev, axp20x_batt, info);
 		power_supply_put_battery_info(axp20x_batt->batt, info);
+		axp20x_batt->energy_full_design = info->energy_full_design_uwh;
+
+		int cfd = info->charge_full_design_uah;
+
+		// tell pmic about our battery
+		if (cfd) {
+			// [14:8], [7:0], cfd = Value * 1.456mAh
+			cfd = cfd / 1456;
+			regmap_update_bits(axp20x_batt->regmap,
+					   AXP288_FG_DES_CAP0_REG, 0xff,
+					   cfd & 0xff);
+			regmap_update_bits(axp20x_batt->regmap,
+					   AXP288_FG_DES_CAP1_REG, 0xff,
+					   BIT(7) | ((cfd >> 8) & 0xff));
+		} else {
+			dev_warn(axp20x_batt->dev,
+				 "charge full design is not set");
+		}
+	} else {
+		axp20x_batt->energy_full_design = 8000000;
+		dev_warn(axp20x_batt->dev,
+			 "energy full design is not set, default to %d\n",
+			 axp20x_batt->energy_full_design);
 	}
 
 	/*
@@ -1138,6 +1223,12 @@
 	 * to current register value by default.
 	 */
 	axp20x_get_constant_charge_current(axp20x_batt, &axp20x_batt->max_ccc);
+
+	regmap_update_bits(axp20x_batt->regmap, AXP20X_VBUS_IPSOUT_MGMT, 0x03, 0x03);
+	regmap_update_bits(axp20x_batt->regmap, AXP20X_OFF_CTRL, 0x08, 0x08);
+	regmap_update_bits(axp20x_batt->regmap, AXP20X_CHRG_CTRL2, 0x30, 0x20);
+	regmap_update_bits(axp20x_batt->regmap, AXP20X_PEK_KEY, 0x0f, 0x0b);
+	regmap_update_bits(axp20x_batt->regmap, AXP20X_GPIO0_CTRL, 0x07, 0x00);
 
 	return 0;
 }
